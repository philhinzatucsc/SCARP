import numpy as np
import matplotlib.pyplot as plt
from astropy.modeling import models, fitting
from scipy.special import jv

'''
Optical Turbulence Profiles for Mauna Kea
 used in SCARP
'''

# Define Optical Turbulence Profile
#Chun model
#factor_chun = 3                                    #factor added to match open loop images at 0.5 um
factor_chun = 1
lowlayers = [ 1,15,30,45,60,75,90,105,120,160,240,320,400,480,560]
Jlowcoeff = np.array([[48.6, 115., 167.],
                [53.0, 45.1, 79.9],
                [19.7, 15.8,  14.0 ],
                [6.53 , 11.0 , 12.3],
                [0.135, 0.412 ,2.86 ],
                [0.017 ,0.11 , 1.72],
                [0.00 , 0.0258, 3.55],
                [0.00 , 0.0089, 1.87],
                [0.00 , 0.073, 2.35],
                [2.4 , 5.55, 10.9],
                [2.53 , 4.51, 9.37],
                [1.06 , 1.81, 4.03],
                [1.09 , 0.699, 1.57],
                [0.307 , 0, 0],
                [0.264 , 0.145, 0.248]])
highlayers = [500,700,1000,1500,2000,3000,4000,6000,8000,12000,16000,22000 ]
Jhighcoeff = np.array([[6.72 , 10.1, 15.5],
                [2.54 , 4.54, 10.3],
                [1.88 , 3.68, 9.04],
                [1.32 , 2.74, 6.19],
                [2.28 , 4.84, 10.2],
                [2.51 , 6.33, 15.5],
                [2.59 , 6.69, 19.1],
                [4.01 , 10.3, 31.8],
                [7.66 , 18.3, 38.2],
                [9.43 , 14.8, 15.7],
                [3.20 , 3.08, 3.87],
                [2.64 , 3.89, 6.75]])
Jlow = 1 * Jlowcoeff *10**-15 * factor_chun
Jhigh = 1 * Jhighcoeff *10**-15 * factor_chun
#numlayers = len(lowlayers)+len(highlayers)

#Dekany model
factor_dekany = 2 * 0.86      #0.86 added to agree with median r_0 at 0.5 um
factor_dekany = 1
lambda_ref = 0.5E-6
coeff = (lambda_ref /  2 / np.pi)**2 / 0.423
layers_dekany = [ 1,15,30,45,120,200,280,360,440,807,4349,8000,12000,19501]
J_dekany = np.array([
                [0.351,0.431,0.482,0.291,0.302,0.449,0.237,0.334,0.412],
                [0.179,0.220,0.246,0.148,0.154,0.229,0.121,0.170,0.210],
                [0.048,0.059,0.066,0.039,0.041,0.061,0.032,0.045,0.056],
                [0.002,0.003,0.003,0.002,0.002,0.003,0.002,0.002,0.003],
                [0.024,0.030,0.034,0.020,0.021,0.031,0.016,0.023,0.029],
                [0.012,0.014,0.016,0.010,0.010,0.015,0.008,0.011,0.014],
                [0.009,0.011,0.013,0.008,0.008,0.012,0.006,0.009,0.011],
                [0.006,0.007,0.008,0.005,0.005,0.007,0.004,0.006,0.007],
                [0.001,0.001,0.002,0.001,0.001,0.001,0.001,0.001,0.001],
                [0.087,0.052,0.031,0.112,0.107,0.045,0.135,0.094,0.060],
                [0.116,0.071,0.041,0.150,0.144,0.060,0.181,0.126,0.081],
                [0.075,0.046,0.027,0.097,0.093,0.039,0.117,0.081,0.053],
                [0.061,0.037,0.022,0.078,0.075,0.031,0.095,0.066,0.042],
                [0.029,0.018,0.010,0.038,0.036,0.015,0.045,0.031,0.020]])
r_0 = [0.122,0.137,0.147,0.143,0.168,0.186,0.162,0.198,0.226]
#print(np.size(J_dekany))
#print(np.sum(J_dekany[:,3]))
rows,columns = np.shape(J_dekany)
for col in range(columns) :

    J_dekany[:,col] = coeff * J_dekany[:,col] / (r_0[col] **(5/3)) * factor_dekany
#numlayers = len(layers)